// Generated by @reono/client - DO NOT EDIT
import { createClient, type ClientRequestOptions, type CreateClientOptions } from '@reono/client/runtime';

import type { infer as ZodInfer } from 'zod';
import type * as Schema_0 from '../users/repo.ts';
import type * as Schema_1 from '../todos/repo.ts';

// Route type definitions grouped by HTTP method
export interface RouteDefinitions {
  GET: {
    "/users": {
      params: never;
      body: never;
      response: Array<{ id: number; name: string }>;
    },
    "/users/:userId": {
      params: { userId: string | number };
      body: never;
      response: { id: number; name: string };
    },
    "/": {
      params: never;
      body: never;
      response: Array<{ id: number; name: string }>;
    },
    "/:userId": {
      params: { userId: string | number };
      body: never;
      response: { id: number; name: string };
    },
    "/todos": {
      params: never;
      body: never;
      response: Array<{ id: number; title: string; completed: boolean }>;
    },
    "/todos/:todoId": {
      params: { todoId: string | number };
      body: never;
      response: { id: number; title: string; completed: boolean };
    },
    "/:todoId": {
      params: { todoId: string | number };
      body: never;
      response: { id: number; title: string; completed: boolean };
    }
  },
  PUT: {
    "/users/:userId": {
      params: { userId: string | number };
      body: ZodInfer<typeof Schema_0.userInputSchema>;
      response: { id: number; name: string };
    },
    "/:userId": {
      params: { userId: string | number };
      body: ZodInfer<typeof Schema_0.userInputSchema>;
      response: { id: number; name: string };
    },
    "/todos/:todoId": {
      params: { todoId: string | number };
      body: ZodInfer<typeof Schema_1.todoUpdateSchema>;
      response: { id: number; title: string; completed: boolean };
    },
    "/:todoId": {
      params: { todoId: string | number };
      body: ZodInfer<typeof Schema_1.todoUpdateSchema>;
      response: { id: number; title: string; completed: boolean };
    }
  },
  DELETE: {
    "/users/:userId": {
      params: { userId: string | number };
      body: never;
      response: { message: string };
    },
    "/:userId": {
      params: { userId: string | number };
      body: never;
      response: { message: string };
    },
    "/todos/:todoId": {
      params: { todoId: string | number };
      body: never;
      response: { message: string };
    },
    "/:todoId": {
      params: { todoId: string | number };
      body: never;
      response: { message: string };
    }
  },
  POST: {
    "/users": {
      params: never;
      body: ZodInfer<typeof Schema_0.userInputSchema>;
      response: { id: number; name: string };
    },
    "/": {
      params: never;
      body: ZodInfer<typeof Schema_0.userInputSchema>;
      response: { id: number; name: string };
    },
    "/todos": {
      params: never;
      body: ZodInfer<typeof Schema_1.todoCreateSchema>;
      response: { id: number; title: string; completed: boolean };
    }
  },
  PATCH: {
    "/todos/:todoId": {
      params: { todoId: string | number };
      body: ZodInfer<typeof Schema_1.todoPatchSchema>;
      response: any;
    },
    "/:todoId": {
      params: { todoId: string | number };
      body: ZodInfer<typeof Schema_1.todoPatchSchema>;
      response: any;
    }
  }
}

// Method-specific path types
export type GETPaths = '/users' | '/users/:userId' | '/' | '/:userId' | '/todos' | '/todos/:todoId' | '/:todoId';
export type PUTPaths = '/users/:userId' | '/:userId' | '/todos/:todoId' | '/:todoId';
export type DELETEPaths = '/users/:userId' | '/:userId' | '/todos/:todoId' | '/:todoId';
export type POSTPaths = '/users' | '/' | '/todos';
export type PATCHPaths = '/todos/:todoId' | '/:todoId';

// Union type of all valid paths
export type ValidPaths = '/users' | '/users/:userId' | '/users/:userId' | '/users/:userId' | '/users' | '/' | '/:userId' | '/:userId' | '/:userId' | '/' | '/todos' | '/todos/:todoId' | '/todos' | '/todos/:todoId' | '/todos/:todoId' | '/todos/:todoId' | '/:todoId' | '/:todoId' | '/:todoId' | '/:todoId';

export type PathParams<T extends ValidPaths> = T extends keyof PathParamMap 
  ? PathParamMap[T] 
  : never;

interface PathParamMap {
  '/users/:userId': { userId: string | number };
  '/:userId': { userId: string | number };
  '/todos/:todoId': { todoId: string | number };
  '/:todoId': { todoId: string | number }
}

// Helper types to drive options/response from path
type ParamsOf<M extends keyof RouteDefinitions, P extends keyof RouteDefinitions[M]> =
  RouteDefinitions[M][P] extends { params: infer T } ? T : never;
type BodyOf<M extends keyof RouteDefinitions, P extends keyof RouteDefinitions[M]> =
  RouteDefinitions[M][P] extends { body: infer T } ? T : never;
export type ResponseFor<M extends keyof RouteDefinitions, P extends keyof RouteDefinitions[M]> =
  RouteDefinitions[M][P] extends { response: infer R } ? R : never;
type MaybeParams<M extends keyof RouteDefinitions, P extends keyof RouteDefinitions[M]> =
  [ParamsOf<M, P>] extends [never] ? {} : { params: ParamsOf<M, P> };
type MaybeBody<M extends keyof RouteDefinitions, P extends keyof RouteDefinitions[M]> =
  [BodyOf<M, P>] extends [never] ? {} : { body: BodyOf<M, P> };
export type OptionsFor<M extends keyof RouteDefinitions, P extends keyof RouteDefinitions[M]> =
  Omit<ClientRequestOptions, 'params' | 'body'> & MaybeParams<M, P> & MaybeBody<M, P>;
type HasParams<M extends keyof RouteDefinitions, P extends keyof RouteDefinitions[M]> =
  [ParamsOf<M, P>] extends [never] ? false : true;
type HasBody<M extends keyof RouteDefinitions, P extends keyof RouteDefinitions[M]> =
  [BodyOf<M, P>] extends [never] ? false : true;
type RequiresOptions<M extends keyof RouteDefinitions, P extends keyof RouteDefinitions[M]> =
  HasParams<M, P> extends true ? true : HasBody<M, P> extends true ? true : false;

// Generated client interface
export interface GeneratedApiClient {
  get<TPath extends GETPaths>(...args: RequiresOptions<'GET', TPath> extends true
    ? [path: TPath, options: OptionsFor<'GET', TPath>]
    : [path: TPath, options?: Omit<ClientRequestOptions, 'params' | 'body'>]
  ): Promise<ResponseFor<'GET', TPath>>;
  put<TPath extends PUTPaths>(...args: RequiresOptions<'PUT', TPath> extends true
    ? [path: TPath, options: OptionsFor<'PUT', TPath>]
    : [path: TPath, options?: Omit<ClientRequestOptions, 'params' | 'body'>]
  ): Promise<ResponseFor<'PUT', TPath>>;
  delete<TPath extends DELETEPaths>(...args: RequiresOptions<'DELETE', TPath> extends true
    ? [path: TPath, options: OptionsFor<'DELETE', TPath>]
    : [path: TPath, options?: Omit<ClientRequestOptions, 'params' | 'body'>]
  ): Promise<ResponseFor<'DELETE', TPath>>;
  post<TPath extends POSTPaths>(...args: RequiresOptions<'POST', TPath> extends true
    ? [path: TPath, options: OptionsFor<'POST', TPath>]
    : [path: TPath, options?: Omit<ClientRequestOptions, 'params' | 'body'>]
  ): Promise<ResponseFor<'POST', TPath>>;
  patch<TPath extends PATCHPaths>(...args: RequiresOptions<'PATCH', TPath> extends true
    ? [path: TPath, options: OptionsFor<'PATCH', TPath>]
    : [path: TPath, options?: Omit<ClientRequestOptions, 'params' | 'body'>]
  ): Promise<ResponseFor<'PATCH', TPath>>;
}

// Create the typed client
function createTypedClient(options: CreateClientOptions = {}): GeneratedApiClient {
  const client = createClient({ baseUrl: '/api', ...options });

  const get: GeneratedApiClient["get"] = ((...args: any[]) => {
      const [path, options] = args as [any, any];
      switch (path) {
      case '/users': return client.get(path, options) as Promise<ResponseFor<'GET', '/users'>>;
      case '/users/:userId': return client.get(path, options) as Promise<ResponseFor<'GET', '/users/:userId'>>;
      case '/': return client.get(path, options) as Promise<ResponseFor<'GET', '/'>>;
      case '/:userId': return client.get(path, options) as Promise<ResponseFor<'GET', '/:userId'>>;
      case '/todos': return client.get(path, options) as Promise<ResponseFor<'GET', '/todos'>>;
      case '/todos/:todoId': return client.get(path, options) as Promise<ResponseFor<'GET', '/todos/:todoId'>>;
      case '/:todoId': return client.get(path, options) as Promise<ResponseFor<'GET', '/:todoId'>>;
        default: throw new Error(`Invalid path for GET: ${path}`);
      }
    }) as any;

  const put: GeneratedApiClient["put"] = ((...args: any[]) => {
      const [path, options] = args as [any, any];
      switch (path) {
      case '/users/:userId': return client.put(path, options) as Promise<ResponseFor<'PUT', '/users/:userId'>>;
      case '/:userId': return client.put(path, options) as Promise<ResponseFor<'PUT', '/:userId'>>;
      case '/todos/:todoId': return client.put(path, options) as Promise<ResponseFor<'PUT', '/todos/:todoId'>>;
      case '/:todoId': return client.put(path, options) as Promise<ResponseFor<'PUT', '/:todoId'>>;
        default: throw new Error(`Invalid path for PUT: ${path}`);
      }
    }) as any;

  const del: GeneratedApiClient["delete"] = ((...args: any[]) => {
      const [path, options] = args as [any, any];
      switch (path) {
      case '/users/:userId': return client.delete(path, options) as Promise<ResponseFor<'DELETE', '/users/:userId'>>;
      case '/:userId': return client.delete(path, options) as Promise<ResponseFor<'DELETE', '/:userId'>>;
      case '/todos/:todoId': return client.delete(path, options) as Promise<ResponseFor<'DELETE', '/todos/:todoId'>>;
      case '/:todoId': return client.delete(path, options) as Promise<ResponseFor<'DELETE', '/:todoId'>>;
        default: throw new Error(`Invalid path for DELETE: ${path}`);
      }
    }) as any;

  const post: GeneratedApiClient["post"] = ((...args: any[]) => {
      const [path, options] = args as [any, any];
      switch (path) {
      case '/users': return client.post(path, options) as Promise<ResponseFor<'POST', '/users'>>;
      case '/': return client.post(path, options) as Promise<ResponseFor<'POST', '/'>>;
      case '/todos': return client.post(path, options) as Promise<ResponseFor<'POST', '/todos'>>;
        default: throw new Error(`Invalid path for POST: ${path}`);
      }
    }) as any;

  const patch: GeneratedApiClient["patch"] = ((...args: any[]) => {
      const [path, options] = args as [any, any];
      switch (path) {
      case '/todos/:todoId': return client.patch(path, options) as Promise<ResponseFor<'PATCH', '/todos/:todoId'>>;
      case '/:todoId': return client.patch(path, options) as Promise<ResponseFor<'PATCH', '/:todoId'>>;
        default: throw new Error(`Invalid path for PATCH: ${path}`);
      }
    }) as any;

  return {
    get,
    put,
    delete: del,
    post,
    patch
  } as GeneratedApiClient;
}

// Export the client instance
export const rest = createTypedClient();

// Export the client factory for custom configuration
export { createTypedClient as createRest };
